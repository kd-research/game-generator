# Docker specific
Dockerfile
.dockerignore

# Git
.git
.gitignore

# Python virtual environment
.venv
env/
venv/
ENV/
.env

# Python cache
__pycache__/
*.pyc
*.pyo
*.pyd
*.egg-info/
dist/
build/
wheels/

# IDE / Editor specific
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# OS specific
.DS_Store
Thumbs.db

# Test artifacts and coverage
.cache/
.pytest_cache/
.coverage
.coverage.*
htmlcov/
nosetests.xml
coverage.xml

# Logs
*.log
pip-log.txt

# Other development tools
.tox/
.nox/

# Devcontainer
.devcontainer/

# uv cache
.uv

# Temporary files typically generated by the application that shouldn't be in the image
# Add any specific temporary file patterns your app might generate here, e.g.
# *.tmp
# temp_data/
# output_files/
# workspace_* (if your workspace directories are created in the root and shouldn't be copied)

# If your app creates workspace directories in a predictable pattern at the root
# that are only for runtime and shouldn't be part of the image, add them.
# For example, if initialize_workspace() creates them at the project root:
# /tmp/* (This is usually handled by .gitignore, but good to be explicit if they ever appear in build context)
# If your lib.workspaces.initialize_workspace() could create directories
# in the project root before Docker copies files, you might want to add patterns for those.
# However, your current Dockerfile copies pyproject.toml first, then installs, then copies the rest,
# so runtime-generated workspaces in the root shouldn't be an issue for the COPY . . step.
# The workspaces seem to be created in system temp (/tmp) by default from lib/workspaces.py (tempfile.mkdtemp())
# so they are unlikely to be in the Docker build context unless you change that logic.

# Ensure files needed by the app that might be in .gitignore are NOT in .dockerignore
# For example, if you had 'data/' in .gitignore but needed it in the image:
# !data/ 